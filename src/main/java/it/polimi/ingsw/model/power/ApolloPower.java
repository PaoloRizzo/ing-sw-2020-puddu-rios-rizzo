package it.polimi.ingsw.model.power;

import it.polimi.ingsw.exception.InvalidActionTreeGenerationException;
import it.polimi.ingsw.model.*;

import java.util.ArrayList;
import java.util.List;
/**
 *  Generate ActionTree and prune others ActionTrees for god Apollo
 */
public class ApolloPower extends PowerStrategy {
    /**
     * It uses an overrider move layer instead of default to generate the action tree
     * @param board the current game board
     * @param player the player requesting the action tree
     * @return the action tree generated by the god Apollo
     */
    public ActionTree generateActionTree(Board board, Player player){
        ActionTree root = new ActionTree();
        this.addMoveLayer(root, player, board);
        super.addBuildLayer(root, player, board);
        return root;
    }

    /**
     * Unlike the basic method it can generate forced moves when the worker moves on a space where there is an opponent's worker
     * swapping the two workers
     * @param curr the current action tree
     * @param player the player requesting the action tree
     * @param board the current game board
     */
    protected void addMoveLayer(ActionTree curr, Player player, Board board){
        //inizialmente simulo le mosse
        if(!curr.isRoot())
            throw new InvalidActionTreeGenerationException("Apollo: before move there is always root");

        curr.setAppendedLayer(false);

        List<Worker> workers = new ArrayList<Worker>();

        //scelta libera del worker
        workers.add(player.getWorker(Sex.MALE));
        workers.add(player.getWorker(Sex.FEMALE));

        boolean moved = false;
        for(Worker worker: workers){
            Space currSpace = worker.getSpace();
            for(Space adj: currSpace.getAdjacentSpaces()){
                if(adj.getLevel()<=3 && adj.getLevel()<=currSpace.getLevel()+1 && canMoveAndForce(board, currSpace, adj, player)){
                    boolean win = false, endOfTurn = false;
                    //winning condition
                    if(currSpace.getLevel() == 2 && adj.getLevel() == 3){
                        win = true;
                        endOfTurn = true;
                    }
                    Direction dir = Direction.compareTwoLevels(currSpace.getLevel(), adj.getLevel());
                    Action action;
                    if(adj.hasWorkerOnIt())
                        action = new MoveAndForceAction(worker.toString(), adj.getPosX(), adj.getPosY(), dir, currSpace.getPosX(), currSpace.getPosY(), adj.getWorkerOnIt().toString(), adj.getPosX(), adj.getPosY(), currSpace.getPosX(), currSpace.getPosY());
                    else
                        action = new MoveAction(worker.toString(), adj.getPosX(), adj.getPosY(), dir, currSpace.getPosX(), currSpace.getPosY());
                    moved = true;
                    curr.addChild(new ActionTree(action, win, false, endOfTurn, true));
                }
            }
        }
        if(!moved){
            //can't move with the workers
            curr.setLose(true);
            curr.setEndOfTurn(true);
        }
    }

    /**
     * It is a helper method to determinate if is possible to do a forced move
     * @param board the current game board
     * @param curr the current action tree
     * @param adj the target space where the worker want to go
     * @param player the player requesting the action tree
     * @return true if I can swap my worker with an hypothetical opponent worker on adj
     */
    private boolean canMoveAndForce(Board board, Space curr, Space adj, Player player){
        return (!adj.hasWorkerOnIt() || (adj.hasWorkerOnIt() && adj.getWorkerOnIt() != player.getWorker(Sex.MALE) && adj.getWorkerOnIt() != player.getWorker(Sex.FEMALE)));
    }
}
